---
title: "[SWEA]1954. 달팽이 숫자"
toc: true
category: swea
---

## 1954.달팽이 숫자 .📗

**문제**

달팽이는 1부터 NxN까지의 숫자가 시계방향으로 이루어져 있습니다.

정수 N을 받아서 달팽이를 출력하세요.

**제약 사항**

1 ≤ 달팽이의 크기: N ≤ 10

### 생각해보기

N을 받고 NxN 배열을 만든다고 생각합니다. 달팽이\[a][b] 형태라면, (0,0)부터 b에 1씩 더한 곳에 값이 있다가 b가 N이 되면 달팽이\[0][N]부터 1씩 더합니다.달팽이\[N][N]이되면 이번엔 b에서 1씩 빼고 0이 되면  다시 a에서 1뺍니다.  그리고 해당열에 값이 있으면 멈추고 멈춘 인덱스를 저장합니다.

그리고 다시 b에 1을 더 합니다.

[오른쪽:b +1, 아래:a+ 1,왼쪽:b -1,위: a -1]

이제 한번 구성해 보겠습니다.

```python
T = int(input())
for tc in range(1, T+1):
    N = int(input())
    dal = [[0]*N for _ in range(N)]
    x, y = 0, 0, 
    dir = 'right'
    for i in range(1, (N*N)+1):
        dal[x][y] = i
        if dir == 'right':
            y += 1
            if y == N-1 or dal[x][y+1] != 0:
                dir = 'down'
        elif dir == 'down':
            x += 1
            if x == N-1 or dal[x+1][y] != 0:
                dir = 'left'
        elif dir == 'left':
            y -= 1
            if y == 0 or dal[x][y-1] != 0:
                dir = 'up'
        elif dir == 'up':
            x -= 1
            if x == N - 1 or dal[x-1][y] != 0:
                dir = 'right'
    print(f'#{tc}')            
    for v in range(N):
        print(*dal[v])
```

런타임 에러가 발생했습니다. 어떻게 해결해야 할까요...〒▽〒

---

```python
T = int(input())
for tc in range(1, 1+T):
    N = int(input())
    snail = [[0]*N for _ in range(N)]
    dist = [[0, 1], [1, 0], [0, -1], [-1, 0]]
    d = 0
    s, e = 0, -1
    num = 1
    while num <= (N*N):
        ns = s + dist[d][0]
        ne = e + dist[d][1]
        if 0 <= ns < N and 0 <= ne < N and snail[ns][ne] == 0:
            snail[ns][ne] = num
            num += 1
            s, e = ns, ne
       	else:
            d = (d+1) % 4
    print(f'#{tc}')        
    for i in snail:
        print(*i)
        
```

`snail`이라는 NxN 배열을 만들어 줍니다. 그리고 방향을 조절할 `dist`를 생성합니다.

달팽이 숫자는 시계방향으로 빙글빙글 돕니다. 

보기 쉽게 표로 살펴보자면 N = 3일때

| (0, 0) | (0, 1) | (0, 2) |
| ------ | ------ | ------ |
| (1, 0) | (1, 1) | (1, 2) |
| (2, 0) | (2, 1) | (2, 2) |

이런 형태입니다. 방향 순서가 오른쪽으로 진행되고 끝에 왔을때 아래로 돌아가고 그리고 왼쪽 그리고 위, 이 네가지 방향을 반복합니다.

`우, 하, 좌, 상`의 순서를 반복하며 값을 저장합니다.

그래서 `dist= [[0, 1], [1, 0], [0, -1], [-1, 0]]` 입니다.

그렇다면 처음에 시작을 우리는 오른쪽으로 하기 때문에 방향은 ` 0 `으로 시작합니다.

방향을 d라고 주고 `d = 0`입니다. 그리고 snail에 몇 행 몇열을 정해줘야하기 때문에 우선 `h, i = 0, -1`로 정합니다. i가 -1인 이유는 0, 0부터 시작해서 값을 넣어줘야하는데 dist\[d][1]이 방향을 정해줍니다. 방향을 위해서 1씩 더해주는데 i를 처음부터 0으로 하면 방향의 영향을 받아 바로 오른쪽으로 넘어가 0, 1이 되버립니다. 그렇기 때문에 방향을 생각해서 i = -1입니다.

`num=1`로 넣어줄 숫자의 시작을 가지고 있습니다. while문으로 num이 n*n이 될때까지 잡아줍니다.

그리고 snail의 좌표를 생성해줍니다. 이를 `nh`와 `ni`라고 부르겠습니다.

`nh` = `dist[d][0]`\(방향) + `h`

`ni` = `dist[d][1]`(방향) + `i` 로 정의합니다.

if문으로 이제 조건을 설정해줍니다.

만약 nh와 ni가 인덱스는 0부터 시작하기 때문에 N이 되면 안됩니다. 그러므로 0보다 같거나 크고 N보다 작게 설정하고 snail\[nh][ni]가 0일때, 즉 비어있을때만 값을 넣을 수 있으므로 `snail[nh][ni] == 0`을 조건으로 둡니다.

snail\[nh][ni] 에 num 값을 넣어주고 num은 +1하여 재저장합니다.

그리고 h, i에 `현재 위치를 저장`합니다.

`h, i = nh, ni` 

이를 반복합니다. 그러다가 값이 있는 곳을 만나거나 nh, ni가 N과 같거나 커지면 어떻게 할까요?

이는 범위를 넘어서는 것이기 때문에 `else`로 방향을 만들어줍니다.

 `d = (d+1)%4`로 더 조건에 맞지 않으면 다음 방향으로 이동하게 합니다.



그리고 생성된 `snail`을 한 줄씩 `[ ]`없이 출력하기 위해서는 for문과 `*(unpack)`을 사용해서 한줄씩 출력하도록 합니다.

---

처음에 코드를 보고 이해하기 어려웠습니다. 그래서 종이에 적어가면서 이해했던 것 같습니다. 허허

많은 좋은 코드를 보고 눈에 익혀서 한눈에 뭔지 판단할 줄 아는 날이 왔으면 좋겠습니다.