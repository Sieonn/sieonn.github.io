---
title: "[LG 유레카] 20240613"
toc: true
toc_sticky: true
toc_label: "목차"
---

## 생성자

 **생성자<small>Constructor</small>**

새로운 객체를 생성하기 위해서 초기화 해주는 메서드

- **일반 메소드와의 차이점**

  1. 생성자의 이름은 반드시 클래스명과 일치한다.
  2. 리턴자료형을 명시하지 않는다.`void도 ❌`

- 객체생성시 자동으로 호출

- 클래스 내에 생성자가 하나도 없다면 자바 컴파일러가 **컴파일시 자동으로 <span class="hlm">기본생성자</span>를 추가**

  - 기본생성자는 변수 선언이 하나도 안 들어간 것을 기본 생성자라고 한다.

    ❗ 만약, 클래스 내에 한 개 이상의 생성자가 정의 되어 있다면 컴파일러는 소스코드에 관여안함

    ``` java
    class Abc{
        int su;
        My my;
        Abc(){ //기본생성자(매개변수 비어있는 생성자) --> 초기화(값할당) 메소드
            //멤버필드에 대한 초기화 작업
            su =10;
            my = new My();
            //(일반 메소드 호출 전 1번 실행하는)선행작업
        }// 생성자
        Abc(String name){//오버로딩 생성자
        }
        ABc(int age){
            //컴파일 에러 발새이 클래스명과 일치하지 않으므로 일반 메소드
            //리턴 자료형을 명시하지 않았음
        }
        void hello(){
        }
    }//class Abc
    ```

    





## 인터페이스

인터페이스란 일종의 추상 클래스로 추상메서드와 상수만을 멤버로 가질 수 있고 실제 구현된 것이 전혀없는 기본 설계도 이다.

``` java
interface 인터페이스 명{
    //필드
    [public static final] int su;
    
    //선언된 메서드
    [public abstract] void print();
}
======================================
interface A{
    int su;
    void print();
}

=> 저장: 인터페이스명.java --컴파일--> 인터페이스명.class
```

final 클래스는 서브클래스를 가질수 없다. 즉 부모로 삼을 수 없다는 것이다.



- 인터페이스의 구성멤버는 필드, 선언된 메서드로만 구성

  ``` java
  void print(){
  } //정의된 메서드, 구현된 메서드
  
  void print(); //선언된 메서드(바디가없는, 영역괄호 없는 메서드)
  ```

- 이해를 돕기 위한 비유

  - 손님의 입장

    - 서로 다른 제품에 연결할 수 있는 공통 연결 모듈을 의미

  - 요리사의 입장<small>(객체를 생성하는 곳)</small>

    - 클래스에 다중 상속을 구현할 수 있다.

      ⭐ 인터페이스 사용법

      ​	클래스에 구현해서 사용한다.

      - **키워드: implement**

        ```java
        	class 클래스명 implement 인터페이스명{
        //  	주방		구현의 약속	  메뉴판 
            
        	}
        ```

## 클래스와 인터페이스 간의 상속문법

``` java
class A{}

class B extends A{
    //extends 뒤에는 상속 받고자 하는 한개의 클래스명만 정의
}
```

- extends :확장
  - 자식클래스 확장하는 클래스

``` java
interface A{}
interface B{}

class C implements A,B{// A와 B인터페이스내의 선언된 메서드를 C클래스에서 전부 구현!!
        //구현의 약속
}
```

``` java
interface A{}
class B{}

class C implements A  extends  B { 
   //에러발생: 클래스와 인터페이스를 동시에 상속할 때는 클래스 먼저, 인터페이스 나중
   //implements가 먼저 나오면 컴파일러가 extends Object를 implements키워드 앞에 추가해줌!! 
} ---> (X)

class C extends  B  implements A  {
 
} ---> (O)
```

``` java
interface A { void hello(); }
interface B { void hi(); }

interface C  extends  A,B{
   void good();
}
```

``` java
class A {  void  hello(){}   }

interface B         A{

} ----> 말이 안됨!!
```



## final

1. final 자료형 변수명

   - 마지막 변수: 상수<small>(constant)</small>

   - 상수의 식별을 위해 전체 대문자 표기

     - ex)

       final int MAX = 100;

2. final 리턴형 메서드명() {}

3. final class 클래스명{}