---
title: "[Java]03.연산자"
toc: true
toc_label: "목차"
toc_sticky: true
use_math: true
category: java
---

## 연산자란?

- **연산자**
  - 어떠한 기능을 수행하는 기호(+, -, *, / 등)
- **피연산자**
  - 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
  - 변수 혹은 상수, 리터럴이 될 수 도 있다.

## 연산자의 종류

- 단항 연산자: + - (타입) ++ -- ~ !(not)
- 이항 연산자
  - 산술: + - * / % << >> >>>
  - 비교: > < >= <= == !=
  - 논리: && \|\| & ^ \|
- 삼항 연산자: ? :
- 대입 연산자: =

## 연산자의 우선순위

- 어렵게 생각하지말고 상식적으로 생각합니다.
  - 단항 > 이항
  - 곱셈, 나눗셈 > 덧셈, 뺄셈
  - 산술 > 비교
  - 항상 대입은 맨 끝에
- 괄호의 우선순위가 제일 높습니다.
- 산술>비교>논리>대입
- 단항>이항>삼항
- 연산자의 연산 진행방향은 왼쪽에서 오른쪽이다. 
  단, 단항, 대입 연산자만 오른쪽에서 왼쪽이다.
- 주의!
  - <<, >>, >>>는 덧셈연산자보다 우선순위가 낮다.
    - `x << 2+1은 x<<(2+1)과 같습니다.`
  - \|\|, \|(OR)는 &&, &(AND)보다 우선순위가 낮다.
    - ` x < -1 \|\| x > 3 && X < 5` == `x < -1 \|\| (x > 3) && x < 5`

## 증감 연산자(++, --)

- 증가연산자
- 감소연산자

![image-20240123165102786](../../images/2024-01-23-연산자/image-20240123165102786.png)

## 부호연산자(+, -)와 논리부정연산자(!)

- 부호연산자(+, -): '+'는 피연산자에 1을 곱하고 '_'는 피연산자에 -1을 곱한다.
- 논리부정연산자(!): true는 false로, false는 true로 피연산자가 boolean일 때만 사용가능합니다.

![image-20240123165046111](/../images/2024-01-23-연산자/image-2024012316504611.png)

## 비트전환연산자(~)

정수를 2진수로 표현했을 때, 1을 0으로 0은 1로 바꾼다.

`정수에만 사용가능.`

## 이항연산자의 특징⭐

이항연산자는 연산을 수행하기 전에 피연산자의 타입을 일치시킵니다.

- int`(32비트)`보다 크기가 작은 타입은 int로 변환합니다.

  `(byte, char,short -> int)`

- 피연산자 중 표현범위가 큰 티입으로 형변환 합니다.

![image-20240123165233065](/../images/2024-01-23-연산자/image-2024012316523306.png)

최적화를 위해서 표현범위가 큰 타입으로 형변환 합니다.

{: .notice}

byte a =10;<br/>byte b =20;&nbsp;&nbsp;&nbsp;&nbsp;byte + byte -> int + int -> int<br/>byte c = a + b<br/><br/>byte c = (byte)a + b; //에러<br/>byte c = (byte)(a + b); //OK

<br/>

{: .notice}

int a = 1000000; //1,000,000<br/>int b = 2000000; //2,000,000<br/>long c = a * b; //c는 2,000,000,000,000 ??<br/>//c는 -1454759936입니다.<br/>int * int -> int<br/><br/>long c =(long)a * b; // c는 2,000,000,000,000!<br/>long  * int -> long * long -> long



float이 소숫점까지 나타내기때문에 long보다 큽니다.

{: .notice}

long a = 1000000 * 1000000; // a는 -727,379,968<br/>long b = 1000000 * 1000000L; //b는 1,000,000,000,000<br/><br/><br/>int c = 1000000 * 1000000 / 1000000;  //c는 -727<br/>int d = 1000000 / 1000000 * 1000000; //d는 1,000,000 



값이 커서 오버플로우가 난다. 그렇기 때문에 long으로 바꿔야한다.

정수형태의 데이터에서 오버플로우가 잘 납니다.





![image-20240123171111114](/../images/2024-01-23-연산자/image-20240123171111114.png)

계산하면 char c2 = 98이 나오는데 98을 2바이트 짜리 char에 넣으면 오버플로우가 발생하기 때문에 char로 변경해줘야합니다.

0~9까지에서는 캐릭터 숫자에서 캐릭터 0을 빼면 해당 숫자가 나옵니다.

int i = '2' - '0' = 2

![image-20240123171608366](../../images/2024-01-23-연산자/image-20240123171608366.png)

![image-20240123171655572](../../images/2024-01-23-연산자/image-20240123171655572.png)

## 나머지 연산자(%)

나누기한 나머지를 반환합니다.

## 쉬프트 연산자(<<, >>, >>>)



## 비교 연산자

- 피연산자를 같은 타입으로 변환한 후에 비교한다.

  - 결과 값은 true 또는 false이다.

- 기본형(boolean제외)과 참조형에 사용할 수 있으나 참조형에는 ==와 !=만 사용할 수 있다.

  | 수식   | 연산결과                                        |
  | ------ | ----------------------------------------------- |
  | x > y  | x가 y보다  클 때 true, 그 외에는 false          |
  | x < y  | x가 y보다  작을 때 true, 그 외에는 false        |
  | x >= y | x가 y보다  크거나 같을 때 true, 그 외에는 false |
  | x <= y | x가 y보다  작거나 같을 때 true, 그 외에는 false |
  | x == y | x와 y가  같을 때 true, 그 외에는 false          |
  | x != y | x와 y가보다  다를 때 true, 그 외에는 false      |

  - 'A' < 'B' ➡ 65 < 66 : true
    '0' == 0 ➡ 48 == 0: false

## 비트 연산자

![image-20240123172430911](/../images/2024-01-23-연산자/image-20240123172430911.png)

피연산자를 비트단위로 연산한다.

![image-20240123172523508](../../images/2024-01-23-연산자/image-20240123172523508.png)

이진수로 바꾸고 두 값을 논리 연산 한다.

![image-20240123172619717](/../images/2024-01-23-연산자/image-20240123172619717.png)

## 논리 연산자

## 삼항 연산자

- 조건식의 연산결과가 true이면 ''식1'의 결과를 반환하고 false이면 '식2'의 결과를 반환합니다.

  ​	`(조건식 ? 식1 : 식2)`

## 대입연산자

