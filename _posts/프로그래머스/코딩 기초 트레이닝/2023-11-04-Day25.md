---
title: "[코딩 기초 트레이닝]Day25 조건문 활용, 반복문 활용, 이차원 리스트(배열)"
toc: true
toc_label: "[코딩 기초 트레이닝]Day25 조건문 활용, 반복문 활용, 이차원 리스트(배열)"
toc_sticky: true
category: programmers
---

## 정수를 나선형으로 배치하기 ❌

**문제 설명**

양의 정수 `n`이 매개변수로 주어집니다. `n` × `n` 배열에 1부터 `n`2 까지 정수를 인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 return 하는 solution 함수를 작성해 주세요.

------

**제한사항**

- 1 ≤ `n` ≤ 30

------

**입출력 예**

| n    | result                                                       |
| ---- | ------------------------------------------------------------ |
| 4    | [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] |
| 5    | [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]] |

solution

```python
def solution(n):
    if n == 1:
        return [[1]]
    
    answer = [[0 for j in range(n)] for i in range(n)] # 배열 초기화
    
    x = 0
    y = 0
    dir = 'r'
    
    for i in range(n*n):
        answer[x][y] = i + 1
        if dir == 'r':
            y += 1
            if y == n-1 or answer[x][y+1] != 0: # 맨 끝에 도달했거나 가려는 곳에 이미 값이 있으면 방향 전환
                dir = 'd'
        elif dir == 'd':
            x += 1
            if x == n-1 or answer[x+1][y] != 0:
                dir = 'l'
        elif dir == 'l':
            y -= 1
            if y == 0 or answer[x][y-1] != 0:
                dir = 'u'
        elif dir == 'u':
            x -= 1
            if x == n-1 or answer[x-1][y] != 0:
                dir = 'r'
                
    return answer
```

\1. 배열 값 모두 '0'으로 초기화

\2. 값을 1부터 n*n으로 증가시키며 시계방향으로 회전하면서 배열에 값 채우기

 

우선 진행방향을 right, left, up, down의 4개로 구별해서 dir변수에 저장을 하며 회전할 것이다.

처음 방향을 right로 정해두고 배열의 끝에 도달했거나 진행하려는 곳에 이미 값이 있으면 (즉, 값이 '0'이 아니면) 방향을 바꾼다.

방향의 순서는 시계방향이기 때문에 r > d > l > u이다.

 

처음에 n=1일 때를 고려하지 않았을 때 (코드의 2-3번 줄이 없었을 때) 계속 실패를 하였고 런타임 에러로 떠 더 나은 시간복잡도의 알고리즘이 있나 고민을 했었다.

하지만 다른 블로그를 찾아보니 내가 통과하지 못한 테스트 13의 실행 시간이 다른 테스트에 비해 짧을 것을 보고 n이 작을 때의 예외상황을 생각해보았다.

 

결과적으로 n=1일 때 for문을 돌려보면 13번째 줄에서 answer[0][1]에 엑세스하라는 코드가 되어 index out of range 오류가 발생했던 것이었다.

따라서 이 경우에만 따로 예외처리로 빼두어 이를 해결했다.

```python
def solution(n):
    answer = [[0]*n for _ in range(n)]
    #우,하,좌,상
    dx=[0,1,0,-1]
    dy=[1,0,-1,0]
    x,y=0,0
    answer[x][y]=1
    k=2
    while k<=n*n:
        for i in range(4):
            while True:
                nx=x+dx[i]
                ny=y+dy[i]
                
                if nx>=n or ny>=n or nx<0 or ny<0 or answer[nx][ny]!=0:
                    break
                else:
                    answer[nx][ny]=k
                    x=nx
                    y=ny
                    k+=1
    return answer
```

```python
def solution(n):
    answer = [[None for j in range(n)] for i in range(n)]
    move = [[0, 1], [1, 0], [0, -1], [-1, 0]]
    x, y, m = 0, 0, 0
    for i in range(1, n**2 + 1):
        answer[y][x] = i
        if y + move[m][0] >= n or x + move[m][1] >= n or answer[y + move[m][0]][x + move[m][1]]:
            m = (m + 1) % len(move)
        y, x = y + move[m][0], x + move[m][1]
    return answer
```

