---
title: "[코딩테스트 입문]Day010"
toc: true
toc_sticky: true
toc_label: "목차"
---

## 점의 위치 구하기

**문제 설명**

사분면은 한 평면을 x축과 y축을 기준으로 나눈 네 부분입니다. 사분면은 아래와 같이 1부터 4까지 번호를매깁니다.
![스크린샷 2022-07-07 오후 3.27.04 복사본.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b58d4788-42fa-44fa-af50-481907e65473/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-07-07%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%203.27.04%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1%E1%84%87%E1%85%A9%E1%86%AB.png)

- x 좌표와 y 좌표가 모두 양수이면 제1사분면에 속합니다.
- x 좌표가 음수, y 좌표가 양수이면 제2사분면에 속합니다.
- x 좌표와 y 좌표가 모두 음수이면 제3사분면에 속합니다.
- x 좌표가 양수, y 좌표가 음수이면 제4사분면에 속합니다.

x 좌표 (x, y)를 차례대로 담은 정수 배열 `dot`이 매개변수로 주어집니다. 좌표 `dot`이 사분면 중 어디에 속하는지 1, 2, 3, 4 중 하나를 return 하도록 solution 함수를 완성해주세요.

------

**제한사항**

- `dot`의 길이 = 2
- `dot[0]`은 x좌표를, `dot[1]`은 y좌표를 나타냅니다
- -500 ≤ `dot`의 원소 ≤ 500
- `dot`의 원소는 0이 아닙니다.

------

**입출력 예**

| dot     | result |
| ------- | ------ |
| [2, 4]  | 1      |
| [-7, 9] | 2      |

---

**문제 풀이**

```python
def solution(dot):
    if dot[0]*dot[1] > 0:
        if dot[0] > 0:
            return 1
        else:
            return 3
    if dot[0]*dot[1] < 0:
        if dot[0] < 0:
            return 2
        else:
            return 4
        
```

```python
def solution(dot):
    quad = [(3,2),(4,1)]
    return quad[dot[0] > 0][dot[1] > 0]
```

아래의 풀이를 보면 4분면을 `quad`로 저장하고 x축이 양수일 경우 quad[1]

y축이 양수일 경우 quad\[1][1]로 1이 return 됩니다.

간단하면서 이해도 쉬운 코드인것 같습니다.

---

## 2차원으로 만들기

**문제 설명**

정수 배열 `num_list`와 정수 `n`이 매개변수로 주어집니다. `num_list`를 다음 설명과 같이 2차원 배열로 바꿔 return하도록 solution 함수를 완성해주세요.

`num_list`가 [1, 2, 3, 4, 5, 6, 7, 8] 로 길이가 8이고 `n`이 2이므로 `num_list`를 2 * 4 배열로 다음과 같이 변경합니다. 2차원으로 바꿀 때에는 num_list의 원소들을 앞에서부터 n개씩 나눠 2차원 배열로 변경합니다.

| num_list                 | n    | result                           |
| ------------------------ | ---- | -------------------------------- |
| [1, 2, 3, 4, 5, 6, 7, 8] | 2    | [[1, 2], [3, 4], [5, 6], [7, 8]] |

------

**제한사항**

- `num_list`의 길이는 `n`의 배 수개입니다.
- 0 ≤ `num_list`의 길이 ≤ 150
- 2 ≤ `n` < `num_list`의 길이

------

**입출력 예**

| num_list                           | n    | result                                   |
| ---------------------------------- | ---- | ---------------------------------------- |
| [1, 2, 3, 4, 5, 6, 7, 8]           | 2    | [[1, 2], [3, 4], [5, 6], [7, 8]]         |
| [100, 95, 2, 4, 5, 6, 18, 33, 948] | 3    | [[100, 95, 2], [4, 5, 6], [18, 33, 948]] |

---

**문제 풀이**

```python
def solution(num_list, n):
    new = []
    for i in range(0, len(num_list), n):
        new.append(num_list[i:i+n])
    return new
```

---

## 공 던지기

**문제 설명**

머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다. 공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다. 친구들의 번호가 들어있는 정수 배열 `numbers`와 정수 `K`가 주어질 때, `k`번째로 공을 던지는 사람의 번호는 무엇인지 return 하도록 solution 함수를 완성해보세요.

------

**제한사항**

- 2 < `numbers`의 길이 < 100
- 0 < `k` < 1,000
- `numbers`의 첫 번째와 마지막 번호는 실제로 바로 옆에 있습니다.
- `numbers`는 1부터 시작하며 번호는 순서대로 올라갑니다.

------

**입출력 예**

| numbers            | k    | result |
| ------------------ | ---- | ------ |
| [1, 2, 3, 4]       | 2    | 3      |
| [1, 2, 3, 4, 5, 6] | 5    | 3      |
| [1, 2, 3]          | 3    | 2      |

---

**문제 풀이**

```python
def solution(numbers, k):
    return numbers[2 * (k - 1) % len(numbers)]
```

이게 numbers[::2]로 한다면 세번째 케이스는 두번째에 3번째에 2여야하지만 1이 나옵니다.

그렇다면 어떻게 해야할까?

우선 기본적으로 1번 다음 3번이니 두칸씩 이동한다고 생각하겠습니다. 그 이동이 k번 있는데, 던지는 사람 기준으로 카운트 됩니다. 그렇기 때문에 바로 1이  카운트 되고 그 다음이 3이 됩니다. 그렇기 때문에 k-1을 2에 곱해줍니다. 그리고 인덱스는 `len(numbers)`를 넘어갈 수 없으니 `len(numbers)`로 나눈 나머지가  k번 던진 인덱스가 됩니다.



{: .notice}

한번에 바로 이해되지 않아서 몇 번 더 읽어봐야 겠습니다.

---

## 배열 회전시키기

**문제 설명**

정수가 담긴 배열 `numbers`와 문자열 `direction`가 매개변수로 주어집니다. 배열 `numbers`의 원소를 `direction`방향으로 한 칸씩 회전시킨 배열을 return하도록 solution 함수를 완성해주세요.

------

**제한사항**

- 3 ≤ `numbers`의 길이 ≤ 20
- `direction`은 "left" 와 "right" 둘 중 하나입니다.

------

**입출력 예**

| numbers                   | direction | result                    |
| ------------------------- | --------- | ------------------------- |
| [1, 2, 3]                 | "right"   | [3, 1, 2]                 |
| [4, 455, 6, 4, -1, 45, 6] | "left"    | [455, 6, 4, -1, 45, 6, 4] |

---

**문제 풀이**

우선 생각해보겠습니다.

함수의 순서가 컨베이어벨트 처럼 right일때는 오른쪽으로 left일때는 왼쪽으로 회전합니다.

그렇다면 이것도 인덱스 내에서 회전하니, 위 문제 처럼 나머지를 가지고 활용해보겠습니다.

```python
def solution(numbers, direction):
    anwser = [0] * len(numbers)
    for i,v in enumerate(numbers):
        if direction == "right":
            anwser[(i+1)%len(numbers)] = v
        else:
            anwser[(i+(len(numbers)-1))%len(numbers)] = v
    return anwser
```

```python
def solution(numbers, direction):
    return [numbers[-1]] + numbers[:-1] if direction == 'right' else numbers[1:] + [numbers[0]]
```

나머지를 가지고 하는법과 아래는 인덱스 범위를 넘어가는 값들을 아예 따로 더해주는 형식입니다. 

right할때 가장 오른쪽에 있는 값이 가장 먼저 오기 때문에 앞에 두고 나머지는 `[:-1]`로 빼둔 마지막 값을 제외하고 더해주는 방법을 사용했습니다.