---
title: "[코딩테스트 입문]Day21"
toc: true
toc_sticky: true
toc_label: "목차"
---

## 숨어있는 숫자의 덧셈(2)

**문제 설명**

문자열 `my_string`이 매개변수로 주어집니다. `my_string`은 소문자, 대문자, 자연수로만 구성되어있습니다. `my_string`안의 자연수들의 합을 return하도록 solution 함수를 완성해주세요.

---

**제한사항**

- 1 ≤ `my_string`의 길이 ≤ 1,000
- 1 ≤ `my_string` 안의 자연수 ≤ 1000
- 연속된 수는 하나의 숫자로 간주합니다.
- 000123과 같이 0이 선행하는 경우는 없습니다.
- 문자열에 자연수가 없는 경우 0을 return 해주세요.

---

**입출력 예**

| my_string       | result |
| --------------- | ------ |
| "aAb1B2cC34oOp" | 37     |
| "1a2b3c4d123Z"  | 133    |

---

**문제 풀이**

```python
def solution(my_string):
    num = ""
    sol = []

    for v, i in enumerate(my_string):
        if i.isdigit():
            if my_string[v-1].isdigit() and v != 0:
                num = num + i
                if v == len(my_string)-1:
                    sol.append(int(num))
            else:
                num += i
                if v == len(my_string)-1:
                    sol.append(int(num))
        else:
            if num != "":
                sol.append(int(num))
                num = ""
    if sol == []:
        return 0
    return sum(sol)
```

반례를 찾는 것이 문제를 푸는데 중요한 요소입니다.

그래서 그 반례가 생기지 않도록 조건을 잘 설정해 줘야합니다.

```python
def solution(my_string):
    s = ''.join(i if i.isdigit() else ' ' for i in my_string)
    return sum(int(i) for i in s.split())
```

다른 풀이를 보고나니까 뭔가 너무 어렵게 접근한 느낌이 들었습니다.

초반에 split()으로 리스트를 생성하는 것 까지 하고 str를 int형으로 만드는 방법을 잠깐 잊어버린...

그리고 위 문제를 보고 map을 사용해 다시 작성해봤습니다.

```python
def solution(my_string):
    s = ''.join(i if i.isdigit() else ' ' for i in my_string)
    return sum(list(map(int,s.split())))
```

---

## 안전지대

**문제 설명**

다음 그림과 같이 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다.

| X | X | X |
| X | 폭탄 | X |
| X | X | X |

지뢰는 2차원 배열 `board`에 1로 표시되어 있고 `board`에는 지뢰가 매설 된 지역 1과, 지뢰가 없는 지역 0만 존재합니다.
지뢰가 매설된 지역의 지도 `board`가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return하도록 solution 함수를 완성해주세요.

------

**제한사항**

- `board`는 n * n 배열입니다.
- 1 ≤ n ≤ 100
- 지뢰는 1로 표시되어 있습니다.
- `board`에는 지뢰가 있는 지역 1과 지뢰가 없는 지역 0만 존재합니다.

------

**입출력 예**

| board                                                        | result |
| ------------------------------------------------------------ | ------ |
| [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0]] | 16     |
| [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 0]] | 13     |
| [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] | 0      |

---

**문제 풀이**

```python
def solution(board):
    N = len(board)
    bomb = [[i, j] for i in range(N) for j in range(N) if board[i][j] == 1]
    if N < 3:
        if len(bomb) > 0:
            return 0
        else:
            return N*N
    region = []
    for x, y in bomb:
        if x - 1 < 0:
            xx = 0
        else:
            xx = x-1
        if y - 1 < 0:
            yy = 0
        else:
            yy = y - 1

        for a in range(xx, x+2):
            for b in range(yy, y+2):
                if [a, b] not in region and a < N and b < N:
                    region.append([a, b])
    print(region)
    if N*N - len(region) > 0:
        return N*N - len(region)
    else:
        return 0
```

---

```python
def solution(board):
    n = len(board)
    danger = set()
    for i, row in enumerate(board):
        for j, x in enumerate(row):
            if not x:
                continue
            danger.update((i+di, j+dj) for di in [-1,0,1] for dj in [-1, 0, 1])
    return n*n - sum(0 <= i < n and 0 <= j < n for i, j in danger)
```

 여기서 좋은 것을 알게 되었습니다. 우선 식도 단순하고 쉽지만 `sum`을 알게 되었는데, for문과 변수를 정해서 더한걸 출력하는것 이외에도 sum을 활용해서 리스트의 값을 더하거나 어떤 조건을 충족하면 카운트하는 기능이 있다는 것을 알 수 있었습니다.