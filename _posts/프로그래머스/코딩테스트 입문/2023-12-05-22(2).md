---
title: "[코딩테스트 입문]Day22-2"
toc: true
toc_sticky: true
toc_label: "목차"
---



## 겹치는 선분의 길이

**문제 설명**

선분 3개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2차원 배열 `lines`가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요.

`lines`가 [[0, 2], [-3, -1], [-2, 1]]일 때 그림으로 나타내면 다음과 같습니다.

![line_2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e4122d8b-9ce2-49ce-a360-3d1284babd8a/line_2.png)

선분이 두 개 이상 겹친 곳은 [-2, -1], [0, 1]로 길이 2만큼 겹쳐있습니다.

------

**제한사항**

- `lines`의 길이 = 3

- `lines`의 원소의 길이 = 2

- 모든 선분은 길이가 1 이상입니다.

- ```
  lines
  ```

  의 원소는 [a, b] 형태이며, a, b는 각각 선분의 양 끝점 입니다.

  - -100 ≤ a < b ≤ 100

------

**입출력 예**

| lines                     | result |
| ------------------------- | ------ |
| [[0, 1], [2, 5], [3, 9]]  | 2      |
| [[-1, 1], [1, 3], [3, 9]] | 0      |
| [[0, 5], [3, 9], [1, 10]] | 8      |

---

**문제 풀이**

<div class = "notice", markdown = "1">
**set: 집합 자료형**<br/>
set()의 괄호 안에 리스트를 입력하여 만들거나 문자열을 입력하여 만들 수도 있습니다.<br/>set의 자료형의 특징은 두가지가 있습니다.<br/>- 중복을 허용하지 않습니다. - 순서가 없습니다.<br/>리스트나 튜플은 중복을 허용하고 순서가 있어서 인덱싱으로 요솟값을 얻을 수 있지만 set은 안됩니다. set의 교집합을 구할때는 `&`을 통해서 구할 수 있습니다. 
```python
a = set([1, 2, 3, 4])
b = set([3, 4, 5])
print(a & b)
>>> {3, 4}
```
같은 결과를 만드는 것이 `intersection`입니다.<br/>`a.intersection(b)`하면 같은 값이 나옵니다.<br/><br/>**합집합**을 구하려면 `|`를 사용합니다. 이때 중복된 값은 하나만 나타납니다.
```python
print(a | b)
>>> {1, 2, 3, 4, 5}
-------------------
a.union(b)
>>> {1, 2, 3, ,4, 5}
```
`union`을 통해서도 합집합을 구할 수 있습니다.<br/>-(빼기)를 사용하면 **차집합**을 구할 수 있습니다.<br/>`add`를 사용하면 만들어진 set자료형에 추가 가능합니다. 한번에 여러개를 추가하고 싶을 때는 `update`를 사용합니다. 특정 값을 제거하고 싶을때는 `remove`를 사용합니다.
</div>





```python
def solution(lines):
    sets = [set(range(min(l), max(l))) for l in lines]
    return len(sets[0] & sets[1] | sets[0] & sets[2] | sets[1] & sets[2])
```





```python
def solution(lines):
    table = [set([]) for _ in range(200)] # -100~100까지 각 선분들의 등장 count 초기화
    for index, line in enumerate(lines):
        x1, x2 = line
        for x in range(x1, x2):
            table[x + 100].add(index) # 선분에 음수가 들어있을 수도 있으므로 +100

    answer = 0
    for line in table:
        if len(line) > 1:
            answer += 1

    return answer
```

기본적으로 'and'는 boolean 형에 기반한 연산에 쓰이고, &는 integer를 기반한 연산에 쓰이는 차이가 있다고 한다. 또,

1. &와 |는 기호에 여러가지 의미가 부여되어 있다. 예를 들어, True & False의 결과는 False 이고, 99 & 7 은 3(2진수 &연산), 위의 set에서는 unions(합집합)/intersection의 의미를 내포한다.
2. and와 or는 짧은 계산을 한다. (&와 |는 그렇지 않음)